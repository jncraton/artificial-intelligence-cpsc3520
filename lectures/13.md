Language
========

Chomsky Hierarchy
-----------------

Grammar       Automaton (Computer)
------------- ----------------------
Unrestricted  Turing Machines
Context Free  Pushdown Automata
Regular       Finite State Automata

Regular Languages
-----------------

- Are insufficient to parse most programming languages
- Are useful for parsing tokens
- Can be processed by a simple finite automaton

Deterministic Finite Automaton (DFA)
------------------------------------

- Finite set of states $Q$
- Finite set of input symbols called the alphabet $\Sigma$
- Transition function $\delta : Q \times \Sigma \rightarrow Q$
- Initial or start state $q_0 \in Q$
- Set of accept states $F \subseteq Q$

Drawing DFAs
------------

- States are nodes on the graph
- Start state indicated by arrow
- Accept states indicated by double border
- Transitions indicated as labelled arrows

---

![DFA to accept string containing an even number of zeroes](https://upload.wikimedia.org/wikipedia/commons/9/9d/DFAexample.svg)

Regular Expressions
-------------------

A string used as a search pattern for a member of a regular language.

RE Basics
---------

- Characters are generally matched literally.

```python
import re

s = "the quick brown fox jumped over the lazy dog"
re.findall("dog", s)
```

```python
['dog']
```

RE Boolean Or
-------------

- Pipes (|) can be used for boolean or

```python
import re

s = "the quick brown fox jumped over the lazy dog"
re.findall("dog|fox", s)
```

```python
['fox', 'dog']
```

RE Quantifiers
--------------

- `?` - zero or one occurences of preceding element
- `*` - zero or more occurences of preceding element
- `+` - one or more occurences of preceding element
- `{n}` - exactly n occurences of preceding element

---

```python
import re

s = "the quick brown fox jumped over the lazy dog"
re.findall("ov?", s)
```

```python
['o', 'o', 'ov', 'o']
```

RE Grouping
-----------

- Parens can be used for grouping

```python
import re

s = "the quick brown fox jumped over the lazy dog"
re.findall("(d|f)o(g|x)", s)
```

```python
[('fox', 'f', 'x'), ('dog', 'd', 'g')]
```

RE Bracket Expressions
----------------------

- Brackets `[]` may be used to match a single character against a set of characters

```python
import re

s = "the quick brown fox jumped over the lazy dog"
re.findall("[df]o[gx]", s)
```

```python
['fox', 'dog']
```

RE Character Classes
--------------------

Several special character classes are provided:

- `\w` - alphanumeric characters
- `\d` - digits
- `\s` - whitespace characters
- `.` - anything

---

```python
import re

s = "the quick brown fox jumped over the lazy dog"
re.findall("\s...\s", s)
```

```python
[' fox ', ' the ']
```

DFA RE Equivalence
------------------

- A DFA can be created to match any regular expression
- A regular expression can be created to match a language accepted by any DFA

Simple Lexer in Python
----------------------

```python
import sys
import re

def lex_one(value):
    if re.match('\d+', value):
        return ('number', value)
    elif re.match('[\+\-\*\/]', value):
        return ('operator', value)
    else:
        raise ValueError(f'Invalid token: {value}')

def lex(text):
    return [lex_one(v) for v in text.split()]
```

Context-free Languages
----------------------

Big Idea
--------

- Grammar rules are applied recursively to generate members of the language.
- Grammar rules can be applied in reverse to parse a string to determine language membership.
- The parsing process can result in a parse tree showing token structure.

English Example
---------------

- S -> NP VP
- NP -> Adj Noun
- NP -> Noun
- VP -> Verb Adv
- VP -> Verb

---

![Parse tree](https://connectiongrammar.netlify.com/docs/english-parse-example.png)

Implementing a parser
---------------------

---

![Parse tree example](https://upload.wikimedia.org/wikipedia/en/thumb/f/fc/Parse_Tree_Example.svg/525px-Parse_Tree_Example.svg.png)


Top-down parsing
----------------

- Begins with overall structure (sometimes guessed or assumed) and then determines details
- Top-down refers to order in which nodes in the final parse tree are determined

---

![Top-down parse](https://upload.wikimedia.org/wikipedia/en/thumb/e/e2/Top-down_Parse_Tree_Order.svg/495px-Top-down_Parse_Tree_Order.svg.png)

Bottom-up parsing
-----------------

- Determines low-level details first then builds our surrounding structure.

---

![Bottom-up parse](https://upload.wikimedia.org/wikipedia/en/thumb/9/9b/Bottom-up_Parse_Tree_Order.svg/501px-Bottom-up_Parse_Tree_Order.svg.png)

Shift-reduce parsing
--------------------

- Bottom-up
- Shifts tokens onto a stack
- Reduces them when they match against a rule

LR Parsing
----------

- Shift-reduce, bottom-up parse
- Left-to-right, Rightmost derivation first
- Deterministic algoritm
- Linear time performance

Parsing English
---------------

> The horse raced past the barn fell.

> The old man the boats.

Punctuation
-----------

> A woman, without her man, is nothing.

> A woman: without her, man is nothing.
